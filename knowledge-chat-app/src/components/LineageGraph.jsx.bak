import React, { useState, useEffect, useMemo } from 'react';
import {
  Box,
  Text,
  VStack,
  HStack,
  Icon,
  Badge,
  Tag,
  TagLabel,
  Heading,
  Button,
  ButtonGroup,
  Tooltip,
  Flex,
  Code,
  Divider,
  IconButton,
} from '@chakra-ui/react';
import { IoChevronUp, IoChevronDown, IoArrowRedo, IoArrowForward, IoArrowUp, IoArrowBack, IoArrowDown } from 'react-icons/io5';
import { MdKeyboardArrowDown, MdKeyboardArrowRight } from 'react-icons/md';
import { TbArrowsRightLeft, TbArrowsHorizontal, TbArrowsVertical, TbZoomIn, TbZoomOut, TbArrowBack, TbArrowForward, TbArrowsMaximize } from 'react-icons/tb';

export const LineageGraph = ({ data }) => {
  // Add error boundary state
  const [hasError, setHasError] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  
  // Add global styles for animations
  useEffect(() => {
    // Add keyframes for the dash animation
    const styleSheet = document.createElement("style");
    styleSheet.id = "lineage-graph-styles";
    styleSheet.textContent = `
      @keyframes dash {
        to {
          stroke-dashoffset: -40;
        }
      }
      
      @keyframes pulse {
        0% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.6;
        }
      }
      
      @keyframes glowPulse {
        0% {
          filter: drop-shadow(0 0 2px rgba(249, 115, 22, 0.3));
        }
        50% {
          filter: drop-shadow(0 0 5px rgba(249, 115, 22, 0.5));
        }
        100% {
          filter: drop-shadow(0 0 2px rgba(249, 115, 22, 0.3));
        }
      }
    `;
    
    // Only add if it doesn't exist yet
    if (!document.getElementById("lineage-graph-styles")) {
      document.head.appendChild(styleSheet);
    }
    
    // Cleanup on unmount
    return () => {
      const existingStyle = document.getElementById("lineage-graph-styles");
      if (existingStyle) {
        existingStyle.remove();
      }
    };
  }, []);
  
  // Default to sample data if none provided
  const graphData = data && (!hasError) ? data : {
    models: [
      { id: 'model1', name: 'order_data', path: 'models/staging/order_data.sql', type: 'staging', highlight: true },
      { id: 'model2', name: 'order_items', path: 'models/intermediate/order_items.sql', type: 'intermediate', highlight: false },
      { id: 'model3', name: 'financial_summary', path: 'models/marts/financial_summary.sql', type: 'mart', highlight: false },
    ],
    edges: [
      { source: 'model1', target: 'model2' },
      { source: 'model2', target: 'model3' },
    ]
  };

  // Add layout state variable
  const [layoutMode, setLayoutMode] = useState('horizontal'); // 'horizontal' or 'vertical'

  // Validate models and edges before processing
  useEffect(() => {
    if (data) {
      try {
        console.log("LineageGraph received data:", data);
        
        // Check if data has valid models and edges
        const valid = 
          data.models && Array.isArray(data.models) && data.models.length > 0 &&
          data.edges && Array.isArray(data.edges);
        
        if (!valid) {
          console.error("LineageGraph received invalid data structure:", data);
          setHasError(true);
          setErrorMessage("Invalid lineage data structure. Missing models or edges.");
        } else {
          // Check if models have required properties
          const modelsValid = data.models.every(model => 
            model.id && (typeof model.id === 'string' || typeof model.id === 'number')
          );
          
          // Check if edges have required properties and reference valid models
          if (data.edges.length > 0) {
            const modelIds = new Set(data.models.map(m => m.id));
            const edgesValid = data.edges.every(edge => 
              edge.source && edge.target && 
              modelIds.has(edge.source) && modelIds.has(edge.target)
            );
            
            if (!modelsValid || !edgesValid) {
              console.error("LineageGraph data has invalid models or edges:", 
                {modelsValid, edgesValid, models: data.models, edges: data.edges});
              setHasError(true);
              setErrorMessage("Invalid models or edges in lineage data.");
            }
          }
          
          // Handle case where there are models but no edges
          if (data.edges.length === 0 && data.models.length > 0) {
            console.warn("LineageGraph data has no edges, but has models. This is unusual for lineage data.");
          }
        }
      } catch (err) {
        console.error("Error validating lineage data:", err);
        setHasError(true);
        setErrorMessage(`Error: ${err.message}`);
      }
    }
  }, [data]);

  // Function to determine which models should be expanded initially
  const getInitialExpandedModels = () => {
    try {
      const result = {};
      
      // Default to expanding all models to see column relationships
      graphData.models.forEach(model => {
        result[model.id] = true;
      });
      
      console.log("Initial expanded models:", result);
      return result;
    } catch (err) {
      console.error("Error in getInitialExpandedModels:", err);
      return {};
    }
  };
  
  // State for tracking expanded models, active edge, and hover state
  const [expandedModels, setExpandedModels] = useState(getInitialExpandedModels());
  const [activeEdge, setActiveEdge] = useState(null);
  const [activeModelId, setActiveModelId] = useState(null);
  const [activeColumnLink, setActiveColumnLink] = useState(null);

  // Function to toggle model expansion
  const toggleModelExpansion = (modelId) => {
    setExpandedModels(prev => ({
      ...prev,
      [modelId]: !prev[modelId]
    }));
  };

  // Get color for model based on its type
  const getModelTypeColor = (type) => {
    switch (type) {
      case 'staging':
        return '#3B82F6'; // Modern blue
      case 'intermediate':
        return '#8B5CF6'; // Modern purple
      case 'mart':
        return '#10B981'; // Modern green
      case 'source':
        return '#F59E0B'; // Modern amber
      case 'upstream':
        return '#06B6D4'; // Modern cyan
      case 'table':
        return '#0EA5E9'; // Modern sky blue
      default:
        return '#64748B'; // Modern slate
    }
  };

  // First, let's update the color palette for column connections with more subtle colors
  const modernColors = {
    blue: {
      light: '#EFF6FF',
      medium: '#DBEAFE',
      default: '#3B82F6',
      dark: '#2563EB',
      darkest: '#1D4ED8'
    },
    purple: {
      light: '#F5F3FF',
      medium: '#E9D5FF',
      default: '#8B5CF6',
      dark: '#7C3AED',
      darkest: '#6D28D9'
    },
    green: {
      light: '#ECFDF5',
      medium: '#D1FAE5',
      default: '#10B981',
      dark: '#059669',
      darkest: '#047857'
    },
    amber: {
      light: '#FFFBEB',
      medium: '#FEF3C7',
      default: '#F59E0B',
      dark: '#D97706',
      darkest: '#B45309'
    },
    slate: {
      light: '#F8FAFC',
      medium: '#E2E8F0',
      default: '#64748B',
      dark: '#475569',
      darkest: '#334155'
    },
    orange: {
      light: '#FFF7ED',
      medium: '#FFEDD5',
      default: '#F97316',
      dark: '#EA580C',
      darkest: '#C2410C'
    },
    gray: {
      50: '#F9FAFB',
      100: '#F3F4F6',
      200: '#E5E7EB',
      300: '#D1D5DB',
      400: '#9CA3AF',
      500: '#6B7280',
      600: '#4B5563',
      700: '#374151',
      800: '#1F2937',
      900: '#111827'
    },
    // Simplified colors for consistency
    key: {
      primary: {
        color: '#64748B', // Use slate for all column types to keep consistent coloring
        activeColor: '#2563EB', // Blue when active
        border: '#E2E8F0',
        activeBorder: '#3B82F6',
        bg: 'white',
        activeBg: 'rgba(59, 130, 246, 0.15)'
      },
      foreign: {
        color: '#64748B', // Use slate for all column types to keep consistent coloring
        activeColor: '#2563EB', // Blue when active
        border: '#E2E8F0',
        activeBorder: '#3B82F6',
        bg: 'white',
        activeBg: 'rgba(59, 130, 246, 0.15)'
      },
      default: {
        color: '#64748B', // Use slate for all column types to keep consistent coloring
        activeColor: '#2563EB', // Blue when active
        border: '#E2E8F0',
        activeBorder: '#3B82F6',
        bg: 'white',
        activeBg: 'rgba(59, 130, 246, 0.15)'
      }
    },
    connection: {
      default: '#94A3B8', // Light slate for inactive connections
      active: '#3B82F6',  // Blue for active connections
      highlight: 'rgba(59, 130, 246, 0.2)' // Light blue highlight
    }
  };
  
  // Update the function to get color for column based on its type
  const getColumnTypeColor = (type, isActive = false) => {
    // Use consistent colors regardless of type when not active
    if (!isActive) {
      return modernColors.key.default.color;
    }
    
    // Only use special colors when active
    switch (type) {
      case 'primary_key':
      case 'foreign_key':
      default:
        return modernColors.blue.default; // Use blue for all active columns
    }
  };
  
  // Function to toggle layout mode
  const toggleLayoutMode = () => {
    setLayoutMode(prevMode => prevMode === "vertical" ? "horizontal" : "vertical");
  };
  
  // Get badge text for model type
  const getModelTypeBadge = (type) => {
    switch (type) {
      case 'staging':
        return 'STG';
      case 'intermediate':
        return 'INT';
      case 'mart':
        return 'MART';
      case 'source':
        return 'SRC';
      case 'upstream':
        return 'UP';
      case 'table':
        return 'TBL';
      default:
        return type?.substring(0, 3).toUpperCase() || 'MOD';
    }
  };
  
  // Add draggable functionality for table boxes
  const [manualPositions, setManualPositions] = useState({});

  // Update layout calculation with more reasonable spacing
  const layout = useMemo(() => {
    try {
      const result = {};
      const levels = {};
      const visited = {};
      
      // Function to calculate the level of each model (distance from source)
      const calculateLevels = () => {
        // Initialize dependency counts and flow tracking
        const inDegree = {};
        const outEdges = {};
        
        // Initialize data structures for all models
        graphData.models.forEach(model => {
          inDegree[model.id] = 0;
          outEdges[model.id] = [];
        });
        
        // Count incoming edges and build outgoing edge list
        graphData.edges.forEach(edge => {
          if (inDegree[edge.target] !== undefined) {
            inDegree[edge.target]++;
          }
          if (outEdges[edge.source]) {
            outEdges[edge.source].push(edge.target);
          }
        });
        
        // Find source nodes (models with no incoming edges)
        const sourceNodes = [];
        for (const modelId in inDegree) {
          if (inDegree[modelId] === 0) {
            sourceNodes.push(modelId);
            levels[modelId] = 0; // Sources are at level 0
          }
        }
        
        // If no source nodes found but we have models, use first model as source
        // This handles cycles or disconnected graphs
        if (sourceNodes.length === 0 && graphData.models.length > 0) {
          const firstModelId = graphData.models[0].id;
          sourceNodes.push(firstModelId);
          levels[firstModelId] = 0;
        }
        
        // Process queue to assign levels using breadth-first search
        const queue = [...sourceNodes];
        while (queue.length > 0) {
          const current = queue.shift();
          visited[current] = true;
          
          // Process outgoing edges
          (outEdges[current] || []).forEach(target => {
            // Update target level to be at least one more than current
            levels[target] = Math.max((levels[current] || 0) + 1, levels[target] || 0);
            
            // Decrement incoming edge count
            inDegree[target]--;
            
            // If all incoming edges processed, add to queue
            if (inDegree[target] === 0) {
              queue.push(target);
            }
          });
        }
        
        // Handle disconnected components or cycles - ensure all models have a level
        graphData.models.forEach(model => {
          if (levels[model.id] === undefined) {
            // Find all models that connect to this one
            const sourceModels = graphData.edges
              .filter(e => e.target === model.id)
              .map(e => e.source);
            
            if (sourceModels.length > 0) {
              // Place after its sources
              const maxSourceLevel = Math.max(...sourceModels.map(id => levels[id] || 0));
              levels[model.id] = maxSourceLevel + 1;
            } else {
              // No sources found, place at level 0
              levels[model.id] = 0;
            }
            visited[model.id] = true;
          }
        });
      };
      
      // Calculate levels based on dependencies
      calculateLevels();
      
      // Group models by level
      const modelsByLevel = {};
      Object.entries(levels).forEach(([modelId, level]) => {
        if (!modelsByLevel[level]) modelsByLevel[level] = [];
        modelsByLevel[level].push(modelId);
      });
      
      // Determine the appropriate spacing based on model count
      const totalModels = graphData.models.length;
      // Use smaller spacing for larger diagrams
      const baseSpacing = totalModels > 12 ? 300 : 
                       (totalModels > 8 ? 350 : 
                       (totalModels > 4 ? 450 : 500));
      
      // Position models based on the layout mode (vertical or horizontal)
      if (layoutMode === "vertical") {
        // VERTICAL LAYOUT (top to bottom)
        const levelCounts = Object.values(modelsByLevel).map(models => models.length);
        const maxModelsPerLevel = Math.max(...levelCounts, 1);
        
        // Use dynamic spacing based on model count and max models per level
        const levelSpacing = baseSpacing;
        // If we have many models per level, reduce horizontal spacing
        const modelSpacing = maxModelsPerLevel > 3 ? baseSpacing - 80 : baseSpacing - 40;
        
        // Calculate the total width needed
        const totalWidth = maxModelsPerLevel * modelSpacing;
        const offsetX = totalWidth / 2; // Center alignment
        
        Object.entries(modelsByLevel).forEach(([level, modelIds]) => {
          const numModels = modelIds.length;
          modelIds.forEach((modelId, index) => {
            // Calculate positions to center models within each level
            const x = (index - (numModels - 1) / 2) * modelSpacing + offsetX;
            const y = parseInt(level) * levelSpacing + 100;
            
            // Use manual position if available, otherwise use calculated position
            result[modelId] = { 
              x: manualPositions[modelId]?.x ?? x, 
              y: manualPositions[modelId]?.y ?? y,
              width: 280, // Slightly narrower model boxes
              height: expandedModels[modelId] ? 280 : 100 // Slightly reduced height
            };
          });
        });
      } else {
        // HORIZONTAL LAYOUT (left to right)
        const levelSpacing = baseSpacing;
        const modelSpacing = baseSpacing - 100;
        
        Object.entries(modelsByLevel).forEach(([level, modelIds]) => {
          const numModels = modelIds.length;
          modelIds.forEach((modelId, index) => {
            // Calculate positions to spread models vertically
            const x = parseInt(level) * levelSpacing + 120;
            const y = (index - (numModels - 1) / 2) * modelSpacing + 250;
            
            // Use manual position if available, otherwise use calculated position
            result[modelId] = { 
              x: manualPositions[modelId]?.x ?? x, 
              y: manualPositions[modelId]?.y ?? y,
              width: 280, // Slightly narrower model boxes
              height: expandedModels[modelId] ? 280 : 100 // Slightly reduced height
            };
          });
        });
      }
      
      return result;
    } catch (err) {
      console.error("Error calculating layout:", err);
      return {};
    }
  }, [graphData, layoutMode, expandedModels, manualPositions]);

  // Improved viewport size calculation
  const calculateViewportSize = () => {
    if (!layout || Object.keys(layout).length === 0) {
      return { width: 800, height: 600 };
    }
    
    // Calculate the maximum extents of all boxes
    const positions = Object.values(layout);
    const minX = Math.min(...positions.map(pos => pos.x)) - 50;
    const minY = Math.min(...positions.map(pos => pos.y)) - 50;
    const maxX = Math.max(...positions.map(pos => pos.x + pos.width)) + 100;
    const maxY = Math.max(...positions.map(pos => pos.y + pos.height)) + 100;
    
    // Ensure minimum size
    const width = Math.max(maxX - minX, 800);
    const height = Math.max(maxY - minY, 600);
    
    return { width, height, minX, minY, maxX, maxY };
  };

  const viewport = calculateViewportSize();
  const viewportWidth = viewport.width;
  const viewportHeight = viewport.height;

  // Add function to fit all content to the screen
  const fitToView = () => {
    // Only proceed if we have boxes to fit
    if (Object.keys(layout).length === 0) return;
    
    // Get the containing element dimensions
    const container = document.querySelector('.lineage-graph');
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Calculate the scale needed to fit the content
    const scaleX = containerWidth / viewport.width;
    const scaleY = containerHeight / viewport.height;
    const scale = Math.min(scaleX, scaleY, 1) * 0.9; // 90% to leave some margin
    
    // Calculate the center point of the content
    const contentCenterX = (viewport.minX + viewport.maxX) / 2;
    const contentCenterY = (viewport.minY + viewport.maxY) / 2;
    
    // Calculate the pan offset to center the content
    const panX = (containerWidth / 2 / scale) - contentCenterX;
    const panY = (containerHeight / 2 / scale) - contentCenterY;
    
    // Apply the new zoom and pan
    setZoomLevel(scale);
    setPanOffset({ x: panX, y: panY });
  };

  // Update the useEffect to ensure fitToView is called
  useEffect(() => {
    if (Object.keys(layout).length > 0) {
      // Add a timeout to ensure component is fully rendered before fitting
      setTimeout(fitToView, 300);
    }
  }, [layout, layoutMode]);

  // Also add a call to automatically fit to view on initial render
  useEffect(() => {
    // Call fitToView when component first mounts
    if (Object.keys(layout).length > 0) {
      setTimeout(fitToView, 500);
    }
  }, []); // Empty dependency array for only running on mount

  // Add a reset button to handle layout reset
  const resetLayout = () => {
    // Clear manual positions
    setManualPositions({});
    // Reset zoom and pan
    setZoomLevel(1);
    setPanOffset({ x: 0, y: 0 });
    // Fit to view after a brief delay
    setTimeout(fitToView, 200);
  };

  // Add drag handling for models
  const handleDragStart = (modelId, e) => {
    if (!e.button === 0) return; // Only respond to left mouse button
    e.stopPropagation();
    e.preventDefault();
    
    // Use let instead of const since we reassign these values
    let initialX = e.clientX;
    let initialY = e.clientY;
    let startX = layout[modelId].x;
    let startY = layout[modelId].y;
    
    const handleMouseMove = (moveEvent) => {
      moveEvent.preventDefault();
      
      // Calculate the new position
      const dx = moveEvent.clientX - initialX;
      const dy = moveEvent.clientY - initialY;
      
      // Update position in state
      setManualPositions(prev => ({
        ...prev,
        [modelId]: {
          x: startX + dx / zoomLevel,
          y: startY + dy / zoomLevel
        }
      }));
    };
    
    const handleMouseUp = () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Find the original columnLayoutData and update it
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);

  // Remove duplicate renderEdges functions and replace with this updated version
  const renderEdges = () => {
    try {
      // Create a lookup of direct relationships to avoid rendering redundant edges
      const directRelationships = new Set();
      graphData.edges.forEach(edge => {
        directRelationships.add(`${edge.source}-${edge.target}`);
      });

      // Filter out redundant edges (transitively implied relationships)
      const nonRedundantEdges = graphData.edges.filter(edge => {
        // Check if there's a path from source to target via another node
        const hasIndirectPath = graphData.edges.some(e1 => 
          e1.source === edge.source && 
          graphData.edges.some(e2 => 
            e2.source === e1.target && e2.target === edge.target
          )
        );
        
        // Keep the edge if it's not redundant or if it's part of a direct important relationship
        return !hasIndirectPath || edge.important;
      });

      return nonRedundantEdges.map((edge, idx) => {
        // Skip edge if we don't have layout info for source or target
        const sourceModel = layout[edge.source];
        const targetModel = layout[edge.target];
        
        if (!sourceModel || !targetModel) return null;
        
        // Determine if this is horizontal or vertical layout
        const isHorizontal = layoutMode === 'horizontal';
        
        // Calculate start and end points for the edge based on the layout
        let startX, startY, endX, endY;
        
        // Determine relative positions
        const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
        const sourceIsAboveTarget = sourceModel.y < targetModel.y;
        
        // Calculate center points of each model for reference
        const sourceCenter = {
          x: sourceModel.x + sourceModel.width / 2,
          y: sourceModel.y + sourceModel.height / 2
        };
        
        const targetCenter = {
          x: targetModel.x + targetModel.width / 2,
          y: targetModel.y + targetModel.height / 2
        };
        
        // Determine edge attachment points based on relative positions
        if (isHorizontal) {
          if (sourceIsLeftOfTarget) {
            // Standard left-to-right flow
            startX = sourceModel.x + sourceModel.width;
            startY = sourceCenter.y;
            endX = targetModel.x;
            endY = targetCenter.y;
          } else {
            // Reversed right-to-left flow
            startX = sourceModel.x;
            startY = sourceCenter.y;
            endX = targetModel.x + targetModel.width;
            endY = targetCenter.y;
          }
        } else {
          if (sourceIsAboveTarget) {
            // Standard top-to-bottom flow
            startX = sourceCenter.x;
            startY = sourceModel.y + sourceModel.height;
            endX = targetCenter.x;
            endY = targetModel.y;
          } else {
            // Reversed bottom-to-top flow
            startX = sourceCenter.x;
            startY = sourceModel.y;
            endX = targetCenter.x;
            endY = targetModel.y + targetModel.height;
          }
        }
        
        // Calculate control points for bezier curves
        let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
        
        // For horizontal layout
        if (isHorizontal) {
          const distanceX = Math.abs(endX - startX);
          const distanceY = Math.abs(endY - startY);
          
          if (sourceIsLeftOfTarget) {
            // Normal left-to-right flow
            controlPoint1X = startX + distanceX * 0.33;
            controlPoint1Y = startY;
            controlPoint2X = endX - distanceX * 0.33;
            controlPoint2Y = endY;
            
            // Add vertical curve if there's significant Y difference
            if (distanceY > 20) {
              const verticalOffset = Math.min(distanceY * 0.3, 60);
              controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
              controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
            }
          } else {
            // Reversed right-to-left flow
            controlPoint1X = startX - distanceX * 0.33;
            controlPoint1Y = startY;
            controlPoint2X = endX + distanceX * 0.33;
            controlPoint2Y = endY;
            
            // Add vertical curve if there's significant Y difference
            if (distanceY > 20) {
              const verticalOffset = Math.min(distanceY * 0.3, 60);
              controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
              controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
            }
          }
        } 
        // For vertical layout
        else {
          const distanceX = Math.abs(endX - startX);
          const distanceY = Math.abs(endY - startY);
          
          if (sourceIsAboveTarget) {
            // Normal top-to-bottom flow
            controlPoint1X = startX;
            controlPoint1Y = startY + distanceY * 0.33;
            controlPoint2X = endX;
            controlPoint2Y = endY - distanceY * 0.33;
            
            // Add horizontal curve if there's significant X difference
            if (distanceX > 20) {
              const horizontalOffset = Math.min(distanceX * 0.3, 80);
              controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
              controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
            }
          } else {
            // Reverse bottom-to-top flow
            controlPoint1X = startX;
            controlPoint1Y = startY - distanceY * 0.33;
            controlPoint2X = endX;
            controlPoint2Y = endY + distanceY * 0.33;
            
            // Add horizontal curve if there's significant X difference
            if (distanceX > 20) {
              const horizontalOffset = Math.min(distanceX * 0.3, 80);
              controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
              controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
            }
          }
        }
        
        // Create the path string using bezier curve
        const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
        
        // Determine color based on model types
        let color, labelBg, labelColor;
        
        const sourceModelData = graphData.models.find(m => m.id === edge.source);
        const targetModelData = graphData.models.find(m => m.id === edge.target);
        
        if (sourceModelData && targetModelData) {
          // Color edge based on the model types it connects
          if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
            color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
            labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
            labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
          } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
            color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
            labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
            labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
          } else if (targetModelData.type === 'mart') {
            color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
            labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
            labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
          } else {
            color = 'rgba(107, 114, 128, 0.8)'; // Default gray
            labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
            labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
          }
        } else {
          // Default colors
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
        
        // Calculate label position in the middle of the path
        const labelPosition = {
          x: (startX + endX) / 2,
          y: (startY + endY) / 2
        };
        
        // Determine arrow direction based on model positions
        let arrowPath;
        if (isHorizontal) {
          arrowPath = sourceIsLeftOfTarget 
            ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
            : "M 6,-6 L 0,0 L 6,6";   // Left arrow
        } else {
          arrowPath = sourceIsAboveTarget 
            ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
            : "M -6,6 L 0,0 L 6,6";   // Up arrow
        }
        
        return (
          <g key={`${edge.source}-${edge.target}`} className="edge">
            <path
              d={path}
              stroke={color}
              strokeWidth="2"
              strokeDasharray="4,0"
              fill="none"
            />
            
            {/* Arrow at the end */}
            <g transform={`translate(${endX}, ${endY})`}>
              <path 
                d={arrowPath}
                stroke={color}
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                fill="none"
              />
            </g>
            
            {/* Label showing relationship on hover */}
            <g
              onMouseEnter={() => {}} 
              onMouseLeave={() => {}}
            >
              <rect
                x={labelPosition.x - 40}
                y={labelPosition.y - 12}
                width="80"
                height="24"
                rx="12"
                ry="12"
                fill={labelBg}
                stroke={color}
                strokeWidth="1"
                opacity="0"
                style={{
                  transition: 'opacity 0.2s ease',
                }}
                className="edge-label"
              />
              <text
                x={labelPosition.x}
                y={labelPosition.y + 4}
                textAnchor="middle"
                fontSize="12px"
                fontWeight="500"
                fill={labelColor}
                opacity="0"
                style={{
                  transition: 'opacity 0.2s ease',
                  pointerEvents: 'none'
                }}
                className="edge-label-text"
              >
                {edge.label || 'relates to'}
              </text>
            </g>
          </g>
        );
      });
    } catch (err) {
      console.error("Error rendering edges:", err);
      return null;
    }
  };

  // Remove duplicate renderColumnConnections functions and replace with this updated version
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
      
      return (
        <g key={`${edge.source}-${edge.target}`} className="edge">
          <defs>
            <marker
              id={`arrowhead-${edge.source}-${edge.target}`}
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto"
            >
              <path
                d="M 0 0 L 10 5 L 0 10 z"
                fill={color}
              />
            </marker>
          </defs>
          <path
            d={path}
            stroke={color}
            strokeWidth="2"
            strokeDasharray="4,0"
            fill="none"
            markerEnd={`url(#arrowhead-${edge.source}-${edge.target})`}
          />
          
          {/* Arrow at the end */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={color}
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
            />
          </g>
          
          {/* Label showing relationship on hover */}
          <g
            onMouseEnter={() => {}} 
            onMouseLeave={() => {}}
          >
            <rect
              x={labelPosition.x - 40}
              y={labelPosition.y - 12}
              width="80"
              height="24"
              rx="12"
              ry="12"
              fill={labelBg}
              stroke={color}
              strokeWidth="1"
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
              }}
              className="edge-label"
            />
            <text
              x={labelPosition.x}
              y={labelPosition.y + 4}
              textAnchor="middle"
              fontSize="12px"
              fontWeight="500"
              fill={labelColor}
              opacity="0"
              style={{
                transition: 'opacity 0.2s ease',
                pointerEvents: 'none'
              }}
              className="edge-label-text"
            >
              {edge.label || 'relates to'}
            </text>
          </g>
        </g>
      );
    });
  };
  
  // Update renderColumnConnections for consistent styling and better handling of model positions
  const renderColumnConnections = () => {
    if (!graphData.column_lineage || graphData.column_lineage.length === 0) {
      return null;
    }

    // Group column links by model pair for better organization
    const linksByModelPair = {};
    
    graphData.column_lineage.forEach(link => {
      const sourceCol = graphData.columns.find(c => c.id === link.source);
      const targetCol = graphData.columns.find(c => c.id === link.target);
      
      if (!sourceCol || !targetCol) return;
      if (sourceCol.modelId === targetCol.modelId) return; // Skip self references
      
      const modelPairKey = `${sourceCol.modelId}-${targetCol.modelId}`;
      if (!linksByModelPair[modelPairKey]) {
        linksByModelPair[modelPairKey] = [];
      }
      linksByModelPair[modelPairKey].push({ link, sourceCol, targetCol });
    });
    
    // Render all connections with neutral styling by default
    return Object.entries(linksByModelPair).map(([modelPairKey, links]) => {
      if (links.length === 0) return null;
      
      const firstLink = links[0];
      const { sourceCol, targetCol } = firstLink;
      
      // Get layout info for the models
      const sourceModel = layout[sourceCol.modelId];
      const targetModel = layout[targetCol.modelId];
      
      if (!sourceModel || !targetModel) return null;
      
      // Determine relative positions for better connection logic
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Get center positions for the models
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Calculate connection points based on model positions
      const isHorizontal = layoutMode === 'horizontal';
      
      // Determine start and end points based on layout and relative positions
      let startX, startY, endX, endY;
      
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard horizontal flow (left to right)
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed horizontal flow (right to left)
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard vertical flow (top to bottom)
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed vertical flow (bottom to top)
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for elegant curve
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      const distanceX = Math.abs(endX - startX);
      const distanceY = Math.abs(endY - startY);
      
      if (isHorizontal) {
        controlPoint1X = startX + (sourceIsLeftOfTarget ? 1 : -1) * distanceX * 0.33;
        controlPoint1Y = startY;
        controlPoint2X = endX + (sourceIsLeftOfTarget ? -1 : 1) * distanceX * 0.33;
        controlPoint2Y = endY;
        
        // Add vertical curve if needed
        if (distanceY > 20) {
          const verticalOffset = Math.min(distanceY * 0.3, 60);
          controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
          controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
        }
      } else {
        controlPoint1X = startX;
        controlPoint1Y = startY + (sourceIsAboveTarget ? 1 : -1) * distanceY * 0.33;
        controlPoint2X = endX;
        controlPoint2Y = endY + (sourceIsAboveTarget ? -1 : 1) * distanceY * 0.33;
        
        // Add horizontal curve if needed
        if (distanceX > 20) {
          const horizontalOffset = Math.min(distanceX * 0.3, 80);
          controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
          controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
        }
      }
      
      // Create path
      const mainPath = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine the middle point for placing the count badge
      const midX = (startX + endX) / 2;
      const midY = (startY + endY) / 2;
      
      // Check if any columns in this connection are active
      const hasActiveRelation = links.some(linkInfo => 
        activeColumnLink === linkInfo.link.source || activeColumnLink === linkInfo.link.target
      );
      
      // Use neutral color by default, highlighted when active
      const connectionColor = hasActiveRelation 
        ? modernColors.connection.active 
        : modernColors.connection.default;
      
      // Determine arrow direction based on layout and model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }

      return (
        <g key={modelPairKey} className="model-column-connection">
          {/* Main connection path between models */}
          <path
            d={mainPath}
            fill="none"
            stroke={connectionColor}
            strokeWidth={hasActiveRelation ? 1.5 : 1}
            opacity={hasActiveRelation ? 0.9 : 0.6}
            strokeDasharray="4,4"
            style={{ 
              transition: "all 0.2s ease",
              filter: hasActiveRelation ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))' : 'none' 
            }}
          />
          
          {/* Arrow head */}
          <g transform={`translate(${endX}, ${endY})`}>
            <path 
              d={arrowPath}
              stroke={connectionColor}
              strokeWidth={hasActiveRelation ? 1.5 : 1}
              strokeLinecap="round"
              strokeLinejoin="round"
              fill="none"
              style={{ transition: "all 0.2s ease" }}
            />
          </g>
          
          {/* Count badge */}
          <g>
            <circle 
              cx={midX} 
              cy={midY} 
              r={10} 
              fill="white" 
              stroke={connectionColor} 
              strokeWidth={hasActiveRelation ? 1 : 0.5}
              filter="drop-shadow(0 1px 1px rgba(0,0,0,0.05))"
              style={{ transition: "all 0.2s ease" }}
            />
            <text
              x={midX}
              y={midY + 4}
              textAnchor="middle"
              fontSize="10px"
              fontWeight={hasActiveRelation ? "600" : "500"}
              fill={hasActiveRelation ? connectionColor : modernColors.gray[500]}
              style={{ transition: "all 0.2s ease" }}
            >
              {links.length}
            </text>
          </g>
          
          {/* Individual column connections when active */}
          {links.map((linkInfo, idx) => {
            const { link, sourceCol, targetCol } = linkInfo;
            
            // Only draw column-to-column connections when one of the columns is active
            const isActive = activeColumnLink === link.source || activeColumnLink === link.target;
            if (!isActive) return null;
            
            // Only render if we have column layouts
            if (!columnLayoutData[link.source] || !columnLayoutData[link.target]) {
              return null;
            }
            
            const sourceColLayout = columnLayoutData[link.source];
            const targetColLayout = columnLayoutData[link.target];
            
            // Create path for column connection based on model positions
            let colPath;
            
            // Use more dynamic curves that respect the model positions
            if (isHorizontal) {
              if (sourceIsLeftOfTarget) {
                // Normal left to right flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x + sourceColLayout.width + 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + sourceColLayout.width + targetColLayout.x) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x - 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x} ${targetColLayout.y + targetColLayout.height / 2}`;
              } else {
                // Reversed right to left flow
                colPath = `M ${sourceColLayout.x} ${sourceColLayout.y + sourceColLayout.height / 2} 
                         L ${sourceColLayout.x - 15} ${sourceColLayout.y + sourceColLayout.height / 2}
                         Q ${(sourceColLayout.x + targetColLayout.x + targetColLayout.width) / 2} ${sourceColLayout.y + sourceColLayout.height / 2}, 
                           ${targetColLayout.x + targetColLayout.width + 15} ${targetColLayout.y + targetColLayout.height / 2}
                         L ${targetColLayout.x + targetColLayout.width} ${targetColLayout.y + targetColLayout.height / 2}`;
              }
            } else {
              if (sourceIsAboveTarget) {
                // Normal top to bottom flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y + sourceColLayout.height + 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + sourceColLayout.height + targetColLayout.y) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y - 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y}`;
              } else {
                // Reversed bottom to top flow
                colPath = `M ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y} 
                         L ${sourceColLayout.x + sourceColLayout.width / 2} ${sourceColLayout.y - 15}
                         Q ${sourceColLayout.x + sourceColLayout.width / 2} ${(sourceColLayout.y + targetColLayout.y + targetColLayout.height) / 2}, 
                           ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height + 15}
                         L ${targetColLayout.x + targetColLayout.width / 2} ${targetColLayout.y + targetColLayout.height}`;
              }
            }
            
            // Animation for active connections
            const dashLength = 5;
            const dashOffset = -20;
            
            return (
              <g key={`${link.source}-${link.target}`} className="column-connection">
                {/* Main connection path with animation */}
                <path
                  d={colPath}
                  fill="none"
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  opacity={0.9}
                  strokeDasharray={`${dashLength},${dashLength}`}
                  strokeDashoffset={dashOffset}
                  style={{
                    animation: 'dash 15s linear infinite',
                    filter: 'drop-shadow(0 0 1px rgba(0,0,0,0.2))'
                  }}
                />
                
                {/* Highlighted source column */}
                <rect
                  x={sourceColLayout.x}
                  y={sourceColLayout.y}
                  width={sourceColLayout.width}
                  height={sourceColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Highlighted target column */}
                <rect
                  x={targetColLayout.x}
                  y={targetColLayout.y}
                  width={targetColLayout.width}
                  height={targetColLayout.height}
                  fill={modernColors.connection.highlight}
                  rx={6}
                  ry={6}
                  stroke={modernColors.connection.active}
                  strokeWidth={1.5}
                  filter="drop-shadow(0 0 2px rgba(0,0,0,0.1))"
                />
                
                {/* Show relationship information in the middle */}
                <g>
                  <rect
                    x={(sourceColLayout.x + targetColLayout.x) / 2 - 100}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 20}
                    width="200"
                    height="40"
                    fill="white"
                    opacity="0.97"
                    rx="8"
                    ry="8"
                    stroke={modernColors.connection.active}
                    strokeWidth="1"
                    filter="drop-shadow(0 1px 4px rgba(0,0,0,0.15))"
                  />
                  
                  {/* Relationship type */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 - 2}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="bold"
                    fill={modernColors.blue.dark}
                  >
                    Column Relationship
                  </text>
                  
                  {/* Column names */}
                  <text
                    x={(sourceColLayout.x + targetColLayout.x) / 2}
                    y={(sourceColLayout.y + targetColLayout.y) / 2 + 12}
                    textAnchor="middle"
                    fontSize="11px"
                    fontWeight="500"
                    fill={modernColors.slate.dark}
                  >
                    {sourceCol.name} → {targetCol.name}
                  </text>
                </g>
              </g>
            );
          })}
        </g>
      );
    });
  };
  
  // If there's an error, show a user-friendly message
  if (hasError) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="red.300" 
        borderRadius="md" 
        p={4}
        bg="red.50"
        color="red.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization Error</Heading>
        <Text>{errorMessage || "There was an error rendering the lineage visualization."}</Text>
        <Text mt={4} fontSize="sm">Error details:</Text>
        <Code p={2} mt={2} borderRadius="md" bg="red.100" w="100%" maxW="600px">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    );
  }
  
  // If no models or layout couldn't be calculated
  if (Object.keys(layout).length === 0) {
    return (
      <Box 
        w="100%" 
        h="100%" 
        minHeight="300px"
        borderWidth="1px" 
        borderColor="orange.300" 
        borderRadius="md" 
        p={4}
        bg="orange.50"
        color="orange.800"
        display="flex"
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
      >
        <Heading size="md" mb={4}>Lineage Visualization</Heading>
        <Text>Layout calculation failed. Using simplified display.</Text>
        
        {/* Show a simple list of models and their connections */}
        <VStack mt={4} align="start" spacing={2} w="100%">
          <Text fontWeight="bold">Models:</Text>
          {graphData.models.map(model => (
            <HStack key={model.id} spacing={2}>
              <Box 
                w="10px" 
                h="10px" 
                borderRadius="full" 
                bg={getModelTypeColor(model.type)} 
              />
              <Text>{model.name} ({model.type})</Text>
              {model.highlight && <Badge colorScheme="purple">Highlighted</Badge>}
            </HStack>
          ))}
          
          <Text fontWeight="bold" mt={4}>Connections:</Text>
          {graphData.edges.map((edge, idx) => {
            const source = graphData.models.find(m => m.id === edge.source);
            const target = graphData.models.find(m => m.id === edge.target);
            return (
              <Text key={idx}>
                {source?.name || edge.source} → {target?.name || edge.target}
              </Text>
            );
          })}
        </VStack>
      </Box>
    );
  }
  
  // Let's improve the columnLayoutData calculation to prevent overlapping column relationships
  const columnLayoutData = useMemo(() => {
    const data = {};
    
    // Skip if no models or columns
    if (!graphData.models || !graphData.columns || !layout) {
      return data;
    }
    
    // Group columns by model first
    const columnsByModel = {};
    graphData.columns.forEach(column => {
      if (!columnsByModel[column.modelId]) {
        columnsByModel[column.modelId] = [];
      }
      columnsByModel[column.modelId].push(column);
    });
    
    // Now calculate positions with better spacing
    Object.entries(columnsByModel).forEach(([modelId, columns]) => {
      const modelLayout = layout[modelId];
      if (!modelLayout) return;
      
      // Calculate position for each column
      columns.forEach((column, index) => {
        // Calculate positions with more room between columns
        data[column.id] = {
          x: modelLayout.x + 15,
          y: modelLayout.y + 85 + (index * 35), // Increased spacing between columns
          width: modelLayout.width - 30,
          height: 30 // Taller column boxes
        };
      });
    });
    
    return data;
  }, [graphData.models, graphData.columns, layout]);
  
  // Update renderEdges to properly attach arrows to boxes
  const renderEdges = () => {
    // Create a lookup of direct relationships to avoid redundant edges
    const directRelationships = new Set();
    graphData.edges.forEach(edge => {
      directRelationships.add(`${edge.source}-${edge.target}`);
    });
    
    // Filter out redundant edges (those with an indirect path)
    const filteredEdges = graphData.edges.filter(edge => {
      // Keep this edge only if there's no indirect path between source and target
      return true; // Keep all edges for now, can implement transitive reduction later
    });
    
    return filteredEdges.map(edge => {
      const sourceModel = layout[edge.source];
      const targetModel = layout[edge.target];
      
      if (!sourceModel || !targetModel) {
        return null;
      }
      
      // Determine if this is horizontal or vertical layout
      const isHorizontal = layoutMode === 'horizontal';
      
      // Calculate start and end points for the edge based on the layout
      let startX, startY, endX, endY;
      
      // Determine relative positions
      const sourceIsLeftOfTarget = sourceModel.x < targetModel.x;
      const sourceIsAboveTarget = sourceModel.y < targetModel.y;
      
      // Calculate center points of each model for reference
      const sourceCenter = {
        x: sourceModel.x + sourceModel.width / 2,
        y: sourceModel.y + sourceModel.height / 2
      };
      
      const targetCenter = {
        x: targetModel.x + targetModel.width / 2,
        y: targetModel.y + targetModel.height / 2
      };
      
      // Determine edge attachment points based on relative positions
      if (isHorizontal) {
        if (sourceIsLeftOfTarget) {
          // Standard left-to-right flow
          startX = sourceModel.x + sourceModel.width;
          startY = sourceCenter.y;
          endX = targetModel.x;
          endY = targetCenter.y;
        } else {
          // Reversed right-to-left flow
          startX = sourceModel.x;
          startY = sourceCenter.y;
          endX = targetModel.x + targetModel.width;
          endY = targetCenter.y;
        }
      } else {
        if (sourceIsAboveTarget) {
          // Standard top-to-bottom flow
          startX = sourceCenter.x;
          startY = sourceModel.y + sourceModel.height;
          endX = targetCenter.x;
          endY = targetModel.y;
        } else {
          // Reversed bottom-to-top flow
          startX = sourceCenter.x;
          startY = sourceModel.y;
          endX = targetCenter.x;
          endY = targetModel.y + targetModel.height;
        }
      }
      
      // Calculate control points for bezier curves
      let controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y;
      
      // For horizontal layout
      if (isHorizontal) {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsLeftOfTarget) {
          // Normal left-to-right flow
          controlPoint1X = startX + distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX - distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        } else {
          // Reversed right-to-left flow
          controlPoint1X = startX - distanceX * 0.33;
          controlPoint1Y = startY;
          controlPoint2X = endX + distanceX * 0.33;
          controlPoint2Y = endY;
          
          // Add vertical curve if there's significant Y difference
          if (distanceY > 20) {
            const verticalOffset = Math.min(distanceY * 0.3, 60);
            controlPoint1Y = startY + (sourceIsAboveTarget ? verticalOffset : -verticalOffset);
            controlPoint2Y = endY + (sourceIsAboveTarget ? -verticalOffset : verticalOffset);
          }
        }
      } 
      // For vertical layout
      else {
        const distanceX = Math.abs(endX - startX);
        const distanceY = Math.abs(endY - startY);
        
        if (sourceIsAboveTarget) {
          // Normal top-to-bottom flow
          controlPoint1X = startX;
          controlPoint1Y = startY + distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY - distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        } else {
          // Reverse bottom-to-top flow
          controlPoint1X = startX;
          controlPoint1Y = startY - distanceY * 0.33;
          controlPoint2X = endX;
          controlPoint2Y = endY + distanceY * 0.33;
          
          // Add horizontal curve if there's significant X difference
          if (distanceX > 20) {
            const horizontalOffset = Math.min(distanceX * 0.3, 80);
            controlPoint1X = startX + (sourceIsLeftOfTarget ? horizontalOffset : -horizontalOffset);
            controlPoint2X = endX + (sourceIsLeftOfTarget ? -horizontalOffset : horizontalOffset);
          }
        }
      }
      
      // Create the path string using bezier curve
      const path = `M ${startX} ${startY} C ${controlPoint1X} ${controlPoint1Y}, ${controlPoint2X} ${controlPoint2Y}, ${endX} ${endY}`;
      
      // Determine color based on model types
      let color, labelBg, labelColor;
      
      const sourceModelData = graphData.models.find(m => m.id === edge.source);
      const targetModelData = graphData.models.find(m => m.id === edge.target);
      
      if (sourceModelData && targetModelData) {
        // Color edge based on the model types it connects
        if (sourceModelData.type === 'source' && targetModelData.type === 'staging') {
          color = 'rgba(107, 114, 128, 0.8)'; // Gray for source-to-staging
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        } else if (sourceModelData.type === 'staging' && targetModelData.type === 'intermediate') {
          color = 'rgba(79, 70, 229, 0.8)'; // Indigo for staging-to-intermediate
          labelBg = 'rgba(238, 242, 255, 0.95)'; // Light indigo bg
          labelColor = 'rgba(67, 56, 202, 0.9)'; // Indigo text
        } else if (targetModelData.type === 'mart') {
          color = 'rgba(16, 185, 129, 0.8)'; // Green for anything-to-mart
          labelBg = 'rgba(236, 253, 245, 0.95)'; // Light green bg
          labelColor = 'rgba(5, 150, 105, 0.9)'; // Green text
        } else {
          color = 'rgba(107, 114, 128, 0.8)'; // Default gray
          labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
          labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
        }
      } else {
        // Default colors
        color = 'rgba(107, 114, 128, 0.8)'; // Default gray
        labelBg = 'rgba(243, 244, 246, 0.95)'; // Light gray bg
        labelColor = 'rgba(55, 65, 81, 0.9)'; // Dark gray text
      }
      
      // Calculate label position in the middle of the path
      const labelPosition = {
        x: (startX + endX) / 2,
        y: (startY + endY) / 2
      };
      
      // Determine arrow direction based on model positions
      let arrowPath;
      if (isHorizontal) {
        arrowPath = sourceIsLeftOfTarget 
          ? "M -6,-6 L 0,0 L -6,6"  // Right arrow
          : "M 6,-6 L 0,0 L 6,6";   // Left arrow
      } else {
        arrowPath = sourceIsAboveTarget 
          ? "M -6,-6 L 0,0 L 6,-6"  // Down arrow
          : "M -6,6 L 0,0 L 6,6";   // Up arrow
      }
import React, { useState, useEffect, useMemo } from 'react';
import {
  Box,
  Text,
  VStack,
  HStack,
  Icon,
  Badge,
  Tag,
  TagLabel,
  Heading,
  Button,
  ButtonGroup,
  Tooltip,
  Flex,
  Code,
  Divider,
  IconButton,
} from '@chakra-ui/react';
import { IoChevronUp, IoChevronDown, IoArrowRedo, IoArrowForward, IoArrowUp, IoArrowBack, IoArrowDown } from 'react-icons/io5';
import { MdKeyboardArrowDown, MdKeyboardArrowRight } from 'react-icons/md';
import { TbArrowsRightLeft, TbArrowsHorizontal, TbArrowsVertical, TbZoomIn, TbZoomOut, TbArrowBack, TbArrowForward, TbArrowsMaximize } from 'react-icons/tb';

